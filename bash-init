#####################################################################
# DO NOT CHANGE THIS FILE LOCALLY! It provides only a framework
# for finding your own bash config files at ~/.bash-topshell and
# ~/.bash-pershell (or in the equivalent USERS/$LOGNAME area if you've
# chosen to version them). Make your customizations to those files.
# Self-referential environment settings like PATH=$PATH:/foo/bar must
# go in topshell, aliases, functions, and unexported shell variables
# belong in pershell, and non-self-referential environment settings
# such as EDITOR=vim can go either place though topshell is preferred.
# See the README in the same directory as this file for details.
#####################################################################

# Note: we try to use only bash builtins here (avoid fork/exec).

# Debugging aid.
[[ ! -x ~/.bash-verbose ]] || set -x

# This is normally not set, but if set must not be propagated!
unset BASH_ENV

# Cygwin doesn't, or at least at one time didn't, set LOGNAME.
export LOGNAME=${LOGNAME:-${USER:-$(logname)}}

# This is an exported function on RHEL6 which was inadvertently
# allowed to leak into user environments. Red Hat bug, WAR here.
unset module

# Work out the location of the framework.
export BASHRC=${BASH_SOURCE[0]%/*}
[[ ! -f ${BASHRC?} ]] || BASHRC=.

# Find the config files to be sourced. The point here is to
# allow anybody's config files to be sourced, not just our own.
# Anybody using the BASHRC system, that is.
if [[ "$*" == *-user=* ]]; then
    # Source standard/versioned config files of specified user.
    for arg in "$@"; do
        if [[ $arg == -user=* ]]; then
            eval ${arg#-}
            break
        fi
    done
    topshell=$BASHRC/USERS/$user/topshell
    pershell=$BASHRC/USERS/$user/pershell
    if [[ ! -f $topshell ]]; then
        echo "Error: no init files in ${topshell%/*}" >&2
        return 2
    fi
else
    user=${BASHRC%/*}
    user=${user##*/}
    eval home=~$user
    if [[ "$home" = "~$user" ]]; then
        user=${LOGNAME:=$(logname)}
        eval home=~$user
    fi
    topshell=$home/.bash-topshell
    pershell=$home/.bash-pershell
    if [[ ! -f $topshell ]]; then
        topshell=$HOME/.bash-topshell
        pershell=$HOME/.bash-pershell
        if [[ ! -f $topshell && -f $BASHRC/USERS/$user/topshell ]]; then
            topshell=$BASHRC/USERS/$user/topshell
            pershell=$BASHRC/USERS/$user/pershell
        fi
    fi
fi

# These functions can be used in setting up PATH variables.
source $BASHRC/func/pathfuncs

#####################################################################
# Exported settings belong in ~/.bash-topshell
#####################################################################
if [[ "$BASHRC_INIT" != *$user* || "$*" == *-force* ]]; then
    # Use "source $BASHRC/bash-init -reset" to force an initial PATH setting
    if [[ "$*" == *-reset* ]]; then
        echo "$0: RESETTING ENVIRONMENT FOR $user IN $$ FROM $topshell" >&2
        unset BASHRC_INIT
        PATH=/bin:/usr/bin
        [[ ! -r /etc/profile ]] || source /etc/profile
    elif [[ "$*" == *-debug* || "$user" != "$LOGNAME" ]]; then
        echo "$0: ENVIRONMENT INITIALIZATION FOR $user IN $$ FROM $topshell" >&2
    fi
    source $topshell

    # Remove redundant entries in these path variables.
    cleanpath PATH MANPATH

    export BASHRC_INIT=${BASHRC_INIT:+$BASHRC_INIT:}$user
fi

#####################################################################
# Interactive settings belong in ~/.bash-pershell
#####################################################################
if [[ "$*" == *-pershell* && -f $pershell ]]; then
    if [[ "$*" == *-debug* || "$user" != "$LOGNAME" ]]; then
        echo "$0: INTERACTIVE INITIALIZATION FOR $user IN $$ FROM $pershell" >&2
    fi
    source $pershell
fi

unset topshell pershell user home

# Useful for updating active shells after tweaking pershell file.
alias pershell='source $BASHRC/USERS/$LOGNAME/pershell'

# Debugging aid undo.
[[ ! -x ~/.bash-verbose ]] || set +x

: Ensure $? == 0 when this script ends.

# Keep tabs out since human users can't agree on tabstops.
# vim: filetype=sh:sw=4:et:
