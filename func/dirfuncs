#!/bin/bash (just so 'file' says the right thing)

# Written by David Boyce ~1995 and placed in the public domain.

# Minor enhancements to bash's builtin pushd/popd/dirs implementation
# including the following added features:
#
# 1. This version allows you to access the first stacked directory using
#    $lwd ("last working directory") as a shorthand for ${DIRSTACK[1]}.
# 2. It allows you to say "pushd <filename>" which will pushd to
#    "$(dirname <filename>)".
# 3. It will not push a dir to the stack that's already in the stack.
#    Pushing to a dir already on the stack just moves it to the top.

function pushd
{
    if [[ -n "$1" ]]; then
	typeset _tgt=${1%/} _i; shift
	if [[ -f $_tgt ]]; then
	    _tgt="${_tgt%/*}"
	fi
	typeset -i _i=${#DIRSTACK[@]}
	while (( $_i > 0 )); do
	    let _i--
	    if [[ "${DIRSTACK[$_i]}" = "$_tgt" ]]; then
		unset _tgt
		break
	    fi
	done
	if [[ -n "$_tgt" ]]; then
	    set -- "$_tgt" "$@"
	    builtin pushd "$@"
	else
	    builtin pushd +$_i
	fi
    else
	builtin pushd
    fi
    lwd=${DIRSTACK[1]}
}

function popd
{
    builtin popd "$@"
    lwd=${DIRSTACK[1]}
}

function dirs
{
    # Remove accidental redundancies from dir stack. This can
    # happen via e.g. "pushd /var; pushd /var/tmp; cd ..".
    # Bash doesn't allow direct modification of DIRSTACK.
    typeset -a _r _s
    typeset _dir _d _i=0 _n=${#DIRSTACK[@]}
    while [[ $_i < $_n ]]; do
	eval _dir="${DIRSTACK[$_i]}"
	for _d in "${_s[@]}"; do
	    if [[ "$_dir" = "$_d" ]]; then
		_r=($_i ${_r[@]})
		break
	    fi
	done
	_s=("${_s[@]}" $_dir)
	let _i=_i+1
    done
    for _i in "${_r[@]}"; do
	popd +$_i >/dev/null
    done
    builtin dirs "$@"
}
